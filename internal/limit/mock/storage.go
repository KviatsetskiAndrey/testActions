// Code generated by MockGen. DO NOT EDIT.
// Source: ./storage.go

// Package mock_limit is a generated GoMock package.
package mock_limit

import (
	limit "github.com/Confialink/wallet-accounts/internal/limit"
	gomock "github.com/golang/mock/gomock"
	gorm "github.com/jinzhu/gorm"
	reflect "reflect"
)

// MockStorage is a mock of Storage interface
type MockStorage struct {
	ctrl     *gomock.Controller
	recorder *MockStorageMockRecorder
}

// MockStorageMockRecorder is the mock recorder for MockStorage
type MockStorageMockRecorder struct {
	mock *MockStorage
}

// NewMockStorage creates a new mock instance
func NewMockStorage(ctrl *gomock.Controller) *MockStorage {
	mock := &MockStorage{ctrl: ctrl}
	mock.recorder = &MockStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStorage) EXPECT() *MockStorageMockRecorder {
	return m.recorder
}

// Save mocks base method
func (m *MockStorage) Save(value limit.Value, identifier limit.Identifier) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", value, identifier)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save
func (mr *MockStorageMockRecorder) Save(value, identifier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockStorage)(nil).Save), value, identifier)
}

// Update mocks base method
func (m *MockStorage) Update(value limit.Value, identifier limit.Identifier) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", value, identifier)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update
func (mr *MockStorageMockRecorder) Update(value, identifier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockStorage)(nil).Update), value, identifier)
}

// Find mocks base method
func (m *MockStorage) Find(identifier limit.Identifier) ([]limit.Model, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Find", identifier)
	ret0, _ := ret[0].([]limit.Model)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Find indicates an expected call of Find
func (mr *MockStorageMockRecorder) Find(identifier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockStorage)(nil).Find), identifier)
}

// Delete mocks base method
func (m *MockStorage) Delete(identifier limit.Identifier) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", identifier)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete
func (mr *MockStorageMockRecorder) Delete(identifier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockStorage)(nil).Delete), identifier)
}

// MockTransactionalStorage is a mock of TransactionalStorage interface
type MockTransactionalStorage struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionalStorageMockRecorder
}

// MockTransactionalStorageMockRecorder is the mock recorder for MockTransactionalStorage
type MockTransactionalStorageMockRecorder struct {
	mock *MockTransactionalStorage
}

// NewMockTransactionalStorage creates a new mock instance
func NewMockTransactionalStorage(ctrl *gomock.Controller) *MockTransactionalStorage {
	mock := &MockTransactionalStorage{ctrl: ctrl}
	mock.recorder = &MockTransactionalStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTransactionalStorage) EXPECT() *MockTransactionalStorageMockRecorder {
	return m.recorder
}

// Save mocks base method
func (m *MockTransactionalStorage) Save(value limit.Value, identifier limit.Identifier) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", value, identifier)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save
func (mr *MockTransactionalStorageMockRecorder) Save(value, identifier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockTransactionalStorage)(nil).Save), value, identifier)
}

// Update mocks base method
func (m *MockTransactionalStorage) Update(value limit.Value, identifier limit.Identifier) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", value, identifier)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update
func (mr *MockTransactionalStorageMockRecorder) Update(value, identifier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockTransactionalStorage)(nil).Update), value, identifier)
}

// Find mocks base method
func (m *MockTransactionalStorage) Find(identifier limit.Identifier) ([]limit.Model, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Find", identifier)
	ret0, _ := ret[0].([]limit.Model)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Find indicates an expected call of Find
func (mr *MockTransactionalStorageMockRecorder) Find(identifier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockTransactionalStorage)(nil).Find), identifier)
}

// Delete mocks base method
func (m *MockTransactionalStorage) Delete(identifier limit.Identifier) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", identifier)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete
func (mr *MockTransactionalStorageMockRecorder) Delete(identifier interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockTransactionalStorage)(nil).Delete), identifier)
}

// WrapContext mocks base method
func (m *MockTransactionalStorage) WrapContext(db *gorm.DB) limit.TransactionalStorage {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WrapContext", db)
	ret0, _ := ret[0].(limit.TransactionalStorage)
	return ret0
}

// WrapContext indicates an expected call of WrapContext
func (mr *MockTransactionalStorageMockRecorder) WrapContext(db interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WrapContext", reflect.TypeOf((*MockTransactionalStorage)(nil).WrapContext), db)
}
